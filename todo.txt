/*
FIXME:

- rename cleanup.later to cleanup
  but that seems to fuckup clangd :(
  as it removed the build dir, which we need for our includes
  maybe we sould copy that somewhere else with a make target?

- run analyzers with task.json


- we currently have a fork of libcmaes with 2 branches:
  - r-changes: overwites cout logging to Rprintf
  - feat-bipop-budgets: budget fixes for bipop and ipop


- remove all fixmes

- seed is not respected
  https://github.com/CMA-ES/libcmaes/issues/257

- open issue to overwrite logger better / no exit
  https://github.com/CMA-ES/libcmaes/issues/259
  there seems be only this call to stderr
  in cmaparameters.cc, which i commented out
   // std::cerr << "[Warning]: set_vd on non VD algorithm " << this->_algo << ". Not activating VD update\n";
  i have locally fixed that in r_changes

- we should return the executed fevals, but thats currently buggy
  https://github.com/CMA-ES/libcmaes/issues/258
  the returned "fevals" by libcmaes seem to wrong, especially for sepipop and sepabipop
  Where the return value goes wrong (restarts)
IPOPCMA/BIPOP keep a running global count in ESOStrategy::nevals for budgeting/logs, but the CMASolutions object that
gets returned is replaced by the “best run” snapshot, which only contains that run’s local _nevals. IPOP: BIPOP: Note
the log lines use the global ESOStrategy::nevals (cumulative), but the returned CMASolutions is best_run, carrying only
that run’s _nevals. Therefore CMASolutions::fevals() undercounts whenever there are restarts (IPOP/BIPOP, including
sepabipop/sepaBIPOP) or mixed-length runs. This is why your R-side log of objective calls (total across the whole
optimization) can exceed res$fevals.



- at least bipop seems to not respect max_fevals, opened an issue
  https://github.com/CMA-ES/libcmaes/issues/253
  i have locally fixed that in r_changes


- provide readme with install instrauctions and minimal example
- do speed test vs 1-2 other packages and maybe perf test
- run R cmd check
- read all files
- read python version

- consider noisy case
  --> there is set_uh in cmaparams
  --> we have to be careful with the global cache here!!!
- look at surrogates
- support unbounded problems
- allow setting gradients

- but the open issues into a better file

── R CMD check results
──────────────────────────────────────────────────────────────────────────────────────────────────
libcmaesr 0.1 ──── Duration: 3m 25.2s

❯ checking compilation flags in Makevars ... WARNING
  Non-portable flags in variable 'PKG_CXXFLAGS':
    -Wno-unknown-pragmas

❯ checking for GNU extensions in Makefiles ... WARNING
  Found the following file(s) containing GNU extensions:
    src/libcmaes/build/Makefile
    src/libcmaes/build/src/Makefile
  Portable Makefiles do not use GNU extensions such as +=, :=, $(shell),
  $(wildcard), ifeq ... endif, .NOTPARALLEL See section ‘Writing portable
  packages’ in the ‘Writing R Extensions’ manual.

❯ checking compilation flags used ... WARNING
  Compilation used the following non-portable flag(s):
    ‘-Wno-unknown-pragmas’ ‘-mno-omit-leaf-frame-pointer’
  including flag(s) suppressing warnings


❯ checking compiled code ... NOTE
  File ‘libcmaesr/libs/libcmaesr.so’:
    Found ‘_ZSt4cerr’, possibly from ‘std::cerr’ (C++)
      Object: ‘libcmaes/build/src/libcmaes.a’
    Found ‘rand’, possibly from ‘rand’ (C)
      Object: ‘libcmaes/build/src/libcmaes.a’

  Compiled code should not call entry points which might terminate R nor
  write to stdout/stderr instead of to the console, nor use Fortran I/O
  nor system RNGs nor [v]sprintf.

  See ‘Writing portable packages’ in the ‘Writing R Extensions’ manual.




*/
